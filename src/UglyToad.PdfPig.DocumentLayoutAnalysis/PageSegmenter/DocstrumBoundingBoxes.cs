namespace UglyToad.PdfPig.DocumentLayoutAnalysis.PageSegmenter
{
    using Content;
    using Core;
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;

    /// <inheritdoc />
    /// <summary>
    /// The Document Spectrum (Docstrum) algorithm is a bottom-up page segmentation technique based on nearest-neighbourhood 
    /// clustering of connected components extracted from the document. 
    /// This implementation leverages bounding boxes and does not exactly replicates the original algorithm.
    /// <para>See 'The document spectrum for page layout analysis.' by L. O'Gorman.</para>
    /// </summary>
    public class DocstrumBoundingBoxes : IPageSegmenter
    {
        private static readonly double epsilon = 1e-3; //TO DO: not static?
        private static AngleBounds angularDifference = new AngleBounds(-30, 30); //TO DO: not static
        private static int wlBinSize = 10;
        private static int blBinSize = 10;

        /// <summary>
        /// Create an instance of Docstrum for bounding boxes page segmenter, <see cref="DocstrumBoundingBoxes"/>.
        /// </summary>
        public static DocstrumBoundingBoxes Instance { get; } = new DocstrumBoundingBoxes();

        /// <inheritdoc />
        /// <summary>
        /// Get the blocks.
        /// <para>Uses wlAngleLB = -30, wlAngleUB = 30, blAngleLB = -135, blAngleUB = -45, blMulti = 1.3.</para>
        /// </summary>
        /// <param name="words">The words to segment into <see cref="TextBlock"/>s.</param>
        /// <returns>The <see cref="TextBlock"/>s generated by the document spectrum method.</returns>
        public IReadOnlyList<TextBlock> GetBlocks(IEnumerable<Word> words)
        {
            return GetBlocks(words, -1);
        }

        /// <summary>
        /// Get the blocks.
        /// <para>Uses wlAngleLB = -30, wlAngleUB = 30, blAngleLB = -135, blAngleUB = -45, blMulti = 1.3.</para>
        /// </summary>
        /// <param name="words">The words to segment into <see cref="TextBlock"/>s.</param>
        /// <param name="maxDegreeOfParallelism">Sets the maximum number of concurrent tasks enabled. 
        /// <para>A positive property value limits the number of concurrent operations to the set value. 
        /// If it is -1, there is no limit on the number of concurrently running operations.</para></param>
        /// <returns>The <see cref="TextBlock"/>s generated by the document spectrum method.</returns>
        public IReadOnlyList<TextBlock> GetBlocks(IEnumerable<Word> words, int maxDegreeOfParallelism)
        {
            return GetBlocks(words, new AngleBounds(-30, 30), new AngleBounds(45, 135), 3.0, 1.3, maxDegreeOfParallelism);
        }

        /// <summary>
        /// Get the blocks. See original paper for more information.
        /// </summary>
        /// <param name="words">The words to segment into <see cref="TextBlock"/>s.</param>
        /// <param name="withinLine">Angle bounds for words to be considered on the same line.</param>
        /// <param name="betweenLine">Angle bounds for words to be considered on separate lines.</param>
        /// <param name="withinLineMultiplier"></param>
        /// <param name="betweenLineMultiplier">Multiplier that gives the maximum perpendicular distance between
        /// text lines for blocking. Maximum distance will be this number times the between-line
        /// distance found by the analysis.</param>
        /// <returns>The <see cref="TextBlock"/>s generated by the document spectrum method.</returns>
        public IReadOnlyList<TextBlock> GetBlocks(IEnumerable<Word> words,
            AngleBounds withinLine, AngleBounds betweenLine,
            double withinLineMultiplier, double betweenLineMultiplier)
        {
            return GetBlocks(words, withinLine, betweenLine, withinLineMultiplier, betweenLineMultiplier, -1);
        }

        /// <summary>
        /// Get the blocks. See original paper for more information.
        /// </summary>
        /// <param name="words">The words to segment into <see cref="TextBlock"/>s.</param>
        /// <param name="withinLine">Angle bounds for words to be considered on the same line.</param>
        /// <param name="betweenLine">Angle bounds for words to be considered on separate lines.</param>
        /// <param name="withinLineMultiplier"></param>
        /// <param name="betweenLineMultiplier">Multiplier that gives the maximum perpendicular distance between 
        /// text lines for blocking. Maximum distance will be this number times the between-line 
        /// distance found by the analysis.</param>
        /// <param name="maxDegreeOfParallelism">Sets the maximum number of concurrent tasks enabled. 
        /// <para>A positive property value limits the number of concurrent operations to the set value. 
        /// If it is -1, there is no limit on the number of concurrently running operations.</para></param>
        /// <returns>The <see cref="TextBlock"/>s generated by the document spectrum method.</returns>
        public IReadOnlyList<TextBlock> GetBlocks(IEnumerable<Word> words,
            AngleBounds withinLine, AngleBounds betweenLine,
            double withinLineMultiplier, double betweenLineMultiplier,
            int maxDegreeOfParallelism)
        {
            if (words == null)
            {
                return EmptyArray<TextBlock>.Instance;
            }

            var wordsList = new List<Word>();

            foreach (var word in words)
            {
                if (string.IsNullOrWhiteSpace(word.Text))
                {
                    continue;
                }

                wordsList.Add(word);
            }

            if (wordsList.Count == 0)
            {
                return EmptyArray<TextBlock>.Instance;
            }

            // 1. Estimate within line and between line spacing
            if (!GetSpacingEstimation(wordsList, withinLine, betweenLine, wlBinSize, blBinSize,
                maxDegreeOfParallelism,
                out double withinLineDistance, out double betweenLineDistance))
            {
                return new[] { new TextBlock(new[] { new TextLine(wordsList) }) };
            }

            // 2. Determination of Text Lines
            double maxWithinLineDistance = withinLineMultiplier * withinLineDistance; //Math.Min(3 * withinLineDistance.Value, 1.4142 * betweenLineDistance.Value);
            var lines = GetLines(wordsList, maxWithinLineDistance, withinLine, maxDegreeOfParallelism).ToArray();

            // 3. Structural Block Determination
            double maxBetweenLineDistance = betweenLineMultiplier * betweenLineDistance;
            return GetStructuralBlocks(lines, maxBetweenLineDistance, maxDegreeOfParallelism).ToList();
        }

        #region Spacing Estimation
        /// <summary>
        /// Estimation of within-line and between-line spacing.
        /// </summary>
        /// <param name="words"></param>
        /// <param name="withinLine"></param>
        /// <param name="betweenLine"></param>
        /// <param name="wlBinSize"></param>
        /// <param name="blBinSize"></param>
        /// <param name="maxDegreeOfParallelism"></param>
        /// <param name="withinLineDistance"></param>
        /// <param name="betweenLineDistance"></param>
        /// <returns>False if either 'withinLineDistance' or 'betweenLineDistance' is NaN.</returns>
        private static bool GetSpacingEstimation(IReadOnlyList<Word> words,
            AngleBounds withinLine, AngleBounds betweenLine,
            int wlBinSize, int blBinSize,
            int maxDegreeOfParallelism,
            out double withinLineDistance, out double betweenLineDistance)
        {
            ParallelOptions parallelOptions = new ParallelOptions() { MaxDegreeOfParallelism = maxDegreeOfParallelism };

            var withinLineDistList = new ConcurrentBag<double>();
            var betweenLineDistList = new ConcurrentBag<double>();

            // 1. Estimate within line and between line spacing
            KdTree<Word> kdTreeBottomLeft = new KdTree<Word>(words, w => w.BoundingBox.BottomLeft);

            Parallel.For(0, words.Count, parallelOptions, i =>
            {
                var word = words[i];

                // Within-line distance
                // 1.1.1 Find the 2 closest neighbours words to the candidate, using euclidean distance.
                foreach (var n in kdTreeBottomLeft.FindNearestNeighbours(word, 2, w => w.BoundingBox.BottomRight, Distances.Euclidean))
                {
                    // 1.1.2 Check if the neighbour word is within the angle of the candidate 
                    if (withinLine.Contains(AngleWL(word, n.Item1)))
                    {
                        withinLineDistList.Add(Distances.Euclidean(word.BoundingBox.BottomRight, n.Item1.BoundingBox.BottomLeft));
                    }
                }

                // Between-line distance
                // 1.2.1 Find the 2 closest neighbours words to the candidate, using euclidean distance.
                foreach (var n in kdTreeBottomLeft.FindNearestNeighbours(word, 2, w => w.BoundingBox.TopLeft, Distances.Euclidean))
                {
                    // 1.2.2 Check if the candidate words is within the angle
                    var angle = AngleBL(word, n.Item1);
                    if (betweenLine.Contains(angle))
                    {
                        // 1.2.3 Compute the vertical (between-line) distance between the candidate
                        // and the neighbour and add it to the between-line distances list
                        double hypotenuse = Distances.Euclidean(word.BoundingBox.Centroid, n.Item1.BoundingBox.Centroid);

                        // Angle is kept within [-90, 90] 
                        if (angle > 90)
                        {
                            angle -= 180;
                        }

                        var dist = Math.Abs(hypotenuse * Math.Cos((90 - angle) * Math.PI / 180))
                            - word.BoundingBox.Height / 2.0
                            - n.Item1.BoundingBox.Height / 2.0;
                        betweenLineDistList.Add(dist);
                    }
                }
            });

            // Compute average peak value of distribution
            double? withinLinePeak = GetPeakAverageDistance(withinLineDistList, wlBinSize);
            double? betweenLinePeak = GetPeakAverageDistance(betweenLineDistList, blBinSize);

            if (!withinLinePeak.HasValue || !betweenLinePeak.HasValue)
            {
                withinLineDistance = withinLinePeak ?? double.NaN;
                betweenLineDistance = betweenLinePeak ?? double.NaN;
                return false;
            }

            withinLineDistance = withinLinePeak.Value;
            betweenLineDistance = betweenLinePeak.Value;
            return true;
        }

        /// <summary>
        /// Get the average distance value of the peak bucket of the histogram.
        /// </summary>
        /// <param name="distances">The set of distances to average.</param>
        /// <param name="binLength"></param>
        private static double? GetPeakAverageDistance(IEnumerable<double> distances, int binLength = 1)
        {
            if (binLength <= 0)
            {
                throw new ArgumentException();
            }

            var max = (int)Math.Ceiling(distances.Max());
            if (max == 0)
            {
                max = binLength;
            }
            else
            {
                binLength = binLength > max ? max : binLength;
            }

            var bins = Enumerable.Range(0, (int)Math.Ceiling(max / (double)binLength) + 1)
                .Select(x => x * binLength)
                .ToDictionary(x => x, _ => new List<double>());

            foreach (var distance in distances)
            {
                var key = bins.Keys.ElementAt((int)Math.Floor(distance / binLength));
                bins[key].Add(distance);
            }

            var best = default(List<double>);
            foreach (var bin in bins)
            {
                if (best == null || bin.Value.Count > best.Count)
                {
                    best = bin.Value;
                }
            }

            return best?.Average();
        }

        #endregion

        #region Text Lines
        private static IEnumerable<TextLine> GetLines(List<Word> words, double maxWLDistance, AngleBounds withinLine, int maxDegreeOfParallelism)
        {
            var groupedIndexes = Clustering.NearestNeighbours(words,
                2,
                Distances.Euclidean,
                (_, __) => maxWLDistance,
                pivot => pivot.BoundingBox.BottomRight,
                candidate => candidate.BoundingBox.BottomLeft,
                _ => true,
                (pivot, candidate) => withinLine.Contains(AngleWL(pivot, candidate)),
                maxDegreeOfParallelism).ToList();

            for (var a = 0; a < groupedIndexes.Count; a++)
            {
                yield return new TextLine(OrderWords(groupedIndexes[a].Select(i => words[i])));
            }
        }

        /// <summary>
        /// Helper function to compute the within line angle between the pivot's bottom
        /// right and the candidate's bottom left points, taking in account the pivot's rotation.
        /// <para>-90 ≤ θ ≤ 90.</para>
        /// </summary>
        private static double AngleWL(Word pivot, Word candidate)
        {
            var angle = Distances.BoundAngle180(Distances.Angle(pivot.BoundingBox.BottomRight, candidate.BoundingBox.BottomLeft) - pivot.BoundingBox.Rotation);

            // Angle is kept within [-90;90] degree to handle overlapping words
            if (angle > 90)
            {
                angle -= 180;
            }
            else if (angle < -90)
            {
                angle += 180;
            }

            return angle;
        }

        /// <summary>
        /// LtR.
        /// </summary>
        /// <param name="words"></param>
        private static List<Word> OrderWords(IEnumerable<Word> words)
        {
            if (words.Count() <= 1)
            {
                return words.ToList();
            }

            var textDirection = words.First().TextDirection;
            if (textDirection != TextDirection.Other)
            {
                foreach (var word in words)
                {
                    if (word.TextDirection != textDirection)
                    {
                        textDirection = TextDirection.Other;
                        break;
                    }
                }
            }

            switch (textDirection)
            {
                case TextDirection.Horizontal:
                    return words.OrderBy(w => w.BoundingBox.BottomLeft.X).ToList();

                case TextDirection.Rotate180:
                    return words.OrderByDescending(w => w.BoundingBox.BottomLeft.X).ToList();

                case TextDirection.Rotate90:
                    return words.OrderByDescending(w => w.BoundingBox.BottomLeft.Y).ToList();

                case TextDirection.Rotate270:
                    return words.OrderBy(w => w.BoundingBox.BottomLeft.Y).ToList();

                case TextDirection.Other:
                default:
                    // We consider the words roughly have the same rotation.
                    var avgAngle = words.Average(w => w.BoundingBox.Rotation);
                    if (0 < avgAngle && avgAngle <= 90)
                    {
                        // quadrant 1, 0 < θ < π/2
                        return words.OrderBy(w => w.BoundingBox.BottomLeft.X).ThenBy(w => w.BoundingBox.BottomLeft.Y).ToList();
                    }
                    else if (90 < avgAngle && avgAngle <= 180)
                    {
                        // quadrant 2, π/2 < θ ≤ π
                        return words.OrderByDescending(w => w.BoundingBox.BottomLeft.X).ThenBy(w => w.BoundingBox.BottomLeft.Y).ToList();
                    }
                    else if (-180 < avgAngle && avgAngle <= -90)
                    {
                        // quadrant 3, -π < θ < -π/2
                        return words.OrderByDescending(w => w.BoundingBox.BottomLeft.X).ThenByDescending(w => w.BoundingBox.BottomLeft.Y).ToList();
                    }
                    else if (-90 < avgAngle && avgAngle <= 0)
                    {
                        // quadrant 4, -π/2 < θ < 0
                        return words.OrderBy(w => w.BoundingBox.BottomLeft.X).ThenByDescending(w => w.BoundingBox.BottomLeft.Y).ToList();
                    }
                    else
                    {
                        throw new Exception();
                    }
            }
        }
        #endregion

        #region Blocking
        private static IEnumerable<TextBlock> GetStructuralBlocks(TextLine[] lines, double maxBLDistance, int maxDegreeOfParallelism)
        {
            /******************************************************************************************************
             * We want to measure the distance between two lines using the following method:
             *  We check if two lines are overlapping horizontally and compute the perpendicular distance.
             *  We check if the angle between the two line is within 'angularDifference'.
             *  If the two lines are not overlapping or the angle is too wide, the distance is set to the infinity.
             *  
             *  If two text lines are approximately parallel, close in perpendicular distance, and they either 
             *  overlap to some specified degree or are separated by only a small distance in parallel distance, 
             *  then they are said to meet the criteria to belong to the same structural block.
             ******************************************************************************************************/

            var groupedIndexes = Clustering.NearestNeighbours(
                lines,
                (l1, l2) => PerpendicularOverlappingDistance(l1, l2, angularDifference),
                (_, __) => maxBLDistance,
                pivot => new PdfLine(pivot.BoundingBox.BottomLeft, pivot.BoundingBox.BottomRight),
                candidate => new PdfLine(candidate.BoundingBox.TopLeft, candidate.BoundingBox.TopRight),
                _ => true,
                (_, __) => true,
                maxDegreeOfParallelism).ToList();

            for (int a = 0; a < groupedIndexes.Count; a++)
            {
                yield return new TextBlock(OrderLines(groupedIndexes[a].Select(i => lines[i])));
            }
        }

        /// <summary>
        /// Perpendicular overlapping distance.
        /// </summary>
        /// <param name="line1"></param>
        /// <param name="line2"></param>
        /// <param name="angularDifferenceBounds"></param>
        /// <returns>True if overlapped.</returns>
        private static double PerpendicularOverlappingDistance(PdfLine line1, PdfLine line2, AngleBounds angularDifferenceBounds)
        {
            if (GetStructuralBlockingParameters(line1, line2, out double theta, out _, out double ed))
            {
                // Angle is kept within [-90;90]
                if (theta > 90)
                {
                    theta -= 180;
                }
                else if (theta < -90)
                {
                    theta += 180;
                }

                if (!angularDifferenceBounds.Contains(theta))
                {
                    // exclude
                    return double.PositiveInfinity;
                }

                return Math.Abs(ed);
            }
            else
            {
                // nonoverlapped
                return double.PositiveInfinity;
            }
        }

        /// <summary>
        ///
        /// <para>If the 85 ≤ |angularDifference| ≤ 90 (i.e. both lines are or close to or perpendicular) ...</para>
        /// </summary>
        /// <param name="i"></param>
        /// <param name="j"></param>
        /// <param name="angularDifference">The angle between the 2 lines.<para>-180 ≤ θ ≤ 180</para></param>
        /// <param name="normalisedOverlap">Positive value if overlapped, negative value if nonoverlapped.<para>[-1, 1]?</para></param>
        /// <param name="perpendicularDistance">Signed perpendicular distance.</param>
        /// <returns>Return true if overlapped, false if nonoverlapped.</returns>
        public static bool GetStructuralBlockingParameters(PdfLine i, PdfLine j, out double angularDifference, out double normalisedOverlap, out double perpendicularDistance)
        {
            if (AlmostEquals(i, j))
            {
                angularDifference = 0;
                normalisedOverlap = 1;
                perpendicularDistance = 0;
                return true;
            }

            double dXi = i.Point2.X - i.Point1.X;
            double dYi = i.Point2.Y - i.Point1.Y;
            double dXj = j.Point2.X - j.Point1.X;
            double dYj = j.Point2.Y - j.Point1.Y;

            angularDifference = Distances.BoundAngle180((Math.Atan2(dYj, dXj) - Math.Atan2(dYi, dXi)) * 180 / Math.PI);

            if (Math.Abs(angularDifference) > 85 && Math.Abs(angularDifference) < 95)
            {
                // Lines are perpendicular, so we stop here as GetTranslatedPoint() will return nonsense.
                normalisedOverlap = double.NaN;
                perpendicularDistance = double.NaN;
                return false;
            }

            PdfPoint Aj = GetTranslatedPoint(i.Point1.X, i.Point1.Y, j.Point1.X, j.Point1.Y, dXi, dYi, dXj, dYj);
            PdfPoint Bj = GetTranslatedPoint(i.Point2.X, i.Point2.Y, j.Point2.X, j.Point2.Y, dXi, dYi, dXj, dYj);

            // Get middle points
            var ps = new[] { j.Point1, j.Point2, Aj, Bj };

            if (dXj != 0)
            {
                ps = ps.OrderBy(p => p.X).ThenBy(p => p.Y).ToArray();
            }
            else if (dYj != 0)
            {
                ps = ps.OrderBy(p => p.Y).ThenBy(p => p.X).ToArray();
            }

            PdfPoint Cj = ps[1];
            PdfPoint Dj = ps[2];

            bool overlap = true;
            // Cj and Dj should contained within both j and [Aj,Bj]
            if (!PointInLine(j.Point1, j.Point2, Cj) || !PointInLine(j.Point1, j.Point2, Dj) ||
                !PointInLine(Aj, Bj, Cj) || !PointInLine(Aj, Bj, Dj))
            {
                // nonoverlapped
                overlap = false;
            }

            double pj = Math.Sqrt((Dj.Y - Cj.Y) * (Dj.Y - Cj.Y) + (Dj.X - Cj.X) * (Dj.X - Cj.X));
            normalisedOverlap = (overlap ? pj : -pj) / j.Length; // overlap parameter of segment i onto j

            double xMj = (Cj.X + Dj.X) / 2.0;
            double yMj = (Cj.Y + Dj.Y) / 2.0;

            if (!dXi.AlmostEqualsToZero(epsilon) && !dYi.AlmostEqualsToZero(epsilon))
            {
                perpendicularDistance = ((xMj - i.Point1.X) - (yMj - i.Point1.Y) * dXi / dYi) / Math.Sqrt(dXi * dXi / (dYi * dYi) + 1);
            }
            else if (dXi.AlmostEqualsToZero(epsilon))
            {
                perpendicularDistance = xMj - i.Point1.X;
            }
            else
            {
                perpendicularDistance = yMj - i.Point1.Y;
            }

            return overlap;
        }

        private static PdfPoint GetTranslatedPoint(double xPi, double yPi, double xPj, double yPj, double dXi, double dYi, double dXj, double dYj)
        {
            double denominator = dYi * dYj + dXi * dXj;
            if (denominator.AlmostEqualsToZero(epsilon))
            {
                throw new ArgumentException("GetTranslatedPoint(): denominator=0");
            }

            double xTj = (xPi * dXi * dXj + xPj * dYi * dYj + dXj * dYi * (yPi - yPj)) / denominator;
            double yTj = yPj; // TODO: need to check that

            if (dXj > epsilon)
            {
                yTj = dYj / dXj * (xTj - xPj) + yPj;
            }

            return new PdfPoint(xTj, yTj);
        }

        /// <summary>
        /// Helper function to check if the point belongs to the line./>
        /// </summary>
        /// <param name="pl1">Line's first point.</param>
        /// <param name="pl2">Line's second point.</param>
        /// <param name="point">The point to check.</param>
        private static bool PointInLine(PdfPoint pl1, PdfPoint pl2, PdfPoint point)
        {
            // /!\ Assuming the points are aligned (be careful)
            double ax = point.X - pl1.X;
            double ay = point.Y - pl1.Y;
            double bx = pl2.X - pl1.X;
            double by = pl2.Y - pl1.Y;

            double dotProd1 = ax * bx + ay * by;
            if (dotProd1 < 0) return false;

            double dotProd2 = bx * bx + by * by;
            return dotProd1 <= dotProd2;
        }

        /// <summary>
        /// Helper function to check if 2 lines are equal.
        /// </summary>
        /// <param name="line1"></param>
        /// <param name="line2"></param>
        private static bool AlmostEquals(PdfLine line1, PdfLine line2)
        {
            return (line1.Point1.X - line2.Point1.X).AlmostEqualsToZero(epsilon) &&
                   (line1.Point1.Y - line2.Point1.Y).AlmostEqualsToZero(epsilon) &&
                   (line1.Point2.X - line2.Point2.X).AlmostEqualsToZero(epsilon) &&
                   (line1.Point2.Y - line2.Point2.Y).AlmostEqualsToZero(epsilon);
        }

        /// <summary>
        /// Helper function to compute the between line angle between the pivot's
        /// and the candidate's centroid points, taking in account the pivot's rotation.
        /// <para>0 ≤ θ ≤ 180.</para>
        /// </summary>
        private static double AngleBL(Word pivot, Word candidate)
        {
            var angle = Distances.BoundAngle180(Distances.Angle(pivot.BoundingBox.Centroid, candidate.BoundingBox.Centroid) - pivot.BoundingBox.Rotation);

            // Angle is kept within [0, 180] for the check
            if (angle < 0)
            {
                angle += 180;
            }

            return angle;
        }

        private static List<TextLine> OrderLines(IEnumerable<TextLine> lines)
        {
            if (lines.Count() <= 1)
            {
                return lines.ToList();
            }

            var textDirection = lines.First().TextDirection;
            if (textDirection != TextDirection.Other)
            {
                foreach (var line in lines)
                {
                    if (line.TextDirection != textDirection)
                    {
                        textDirection = TextDirection.Other;
                        break;
                    }
                }
            }

            switch (textDirection)
            {
                case TextDirection.Horizontal:
                    return lines.OrderByDescending(w => w.BoundingBox.BottomLeft.Y).ToList();

                case TextDirection.Rotate180:
                    return lines.OrderBy(w => w.BoundingBox.BottomLeft.Y).ToList();

                case TextDirection.Rotate90:
                    return lines.OrderByDescending(w => w.BoundingBox.BottomLeft.X).ToList();

                case TextDirection.Rotate270:
                    return lines.OrderBy(w => w.BoundingBox.BottomLeft.X).ToList();

                case TextDirection.Other:
                default:
                    // We consider the lines roughly have the same rotation.
                    var avgAngle = lines.Average(w => w.BoundingBox.Rotation);
                    if (0 < avgAngle && avgAngle <= 90)
                    {
                        // quadrant 1, 0 < θ < π/2
                        return lines.OrderByDescending(w => w.BoundingBox.BottomLeft.Y).ThenBy(w => w.BoundingBox.BottomLeft.X).ToList();
                    }
                    else if (90 < avgAngle && avgAngle <= 180)
                    {
                        // quadrant 2, π/2 < θ ≤ π
                        return lines.OrderBy(w => w.BoundingBox.BottomLeft.X).ThenBy(w => w.BoundingBox.BottomLeft.Y).ToList();
                    }
                    else if (-180 < avgAngle && avgAngle <= -90)
                    {
                        // quadrant 3, -π < θ < -π/2
                        return lines.OrderBy(w => w.BoundingBox.BottomLeft.Y).ThenByDescending(w => w.BoundingBox.BottomLeft.X).ToList();
                    }
                    else if (-90 < avgAngle && avgAngle <= 0)
                    {
                        // quadrant 4, -π/2 < θ < 0
                        return lines.OrderByDescending(w => w.BoundingBox.BottomLeft.X).ThenByDescending(w => w.BoundingBox.BottomLeft.Y).ToList();
                    }
                    else
                    {
                        throw new Exception();
                    }
            }
        }
        #endregion

        /// <summary>
        /// The bounds for the angle between two words for them to have a certain type of relationship.
        /// </summary>
        public struct AngleBounds
        {
            /// <summary>
            /// The lower bound in degrees.
            /// </summary>
            public double Lower { get; }

            /// <summary>
            /// The upper bound in degrees.
            /// </summary>
            public double Upper { get; }

            /// <summary>
            /// Create a new <see cref="AngleBounds"/>.
            /// </summary>
            public AngleBounds(double lowerBound, double upperBound)
            {
                if (lowerBound >= upperBound)
                {
                    throw new ArgumentException("The lower bound should be smaller than the upper bound.");
                }

                Lower = lowerBound;
                Upper = upperBound;
            }

            /// <summary>
            /// Whether the bounds contain the angle.
            /// </summary>
            public bool Contains(double angle)
            {
                return angle >= Lower && angle <= Upper;
            }
        }
    }
}
